[{"content":"Objective The main objective of CLRS is to introduce frameworks to design and analyze algorithms.\nTerminology Loop Invariant Something used to prove the correctness of an algorithm, with three properties:\n Initialization It is true prior to the first iteration of the loop Maintenance If it is true before an iteration, it remains true after that iteration Termination It helps show that the algorithm is correct after the loop terminates Commonly used in combination with the termination condition  Input Size, $n$ Depends on the problem, but commonly:\n Number of items in the input (sorting, FFT) Number of bits (multiplication)  It can also be described by more than one number, for example:\n Graph vertices and edges.  Runtime, $T(n)$  Number of primitive operations, or \u0026lsquo;steps\u0026rsquo; executed\n Assume each line requires a constant amount of time. The running time of an algorithm is now: $$ \\sum \\text{each individual line} \\times \\text{num of times executed} $$\nRandom-access Machine (RAM) Model Instructions The RAM model contains commonly found instructions:\n Arithmetic (add, subtract, multiple, divide, remainder, floor, ceiling) Data Movement Load, store copy Control (Conditional, unconditional branch, subroutine call, return)  Data Types  Integers Floating point  And assume a limit on size of each word of data.\n For inputs of size $n$, assume integers are represented by $c \\log n$ bits for some constant $c \\geq 1$.\n $c \\geq 1$ : So that each word can hold the value of $n$ to allow us to index the last element $c$ constant : So that word size cannot grow arbitrarily large   Grey Area - Instructions There are some instructions included in real computers that are not in the list above. For example, exponentiation. CLRS assumes that they are constant-time operations for small exponent values.\nMemory Hierarchy The RAM model does not model memory hierarchy, such as caches or virtual memory. This is usually sufficient, and RAM models are excellent at predicting performance of real machines.\nAnalyzing Algorithms  \u0026ldquo;Predict the resources an algorithm requires\u0026rdquo;\n This resource is most often computation time.\nThis kind of analysis requires a model of the hardware that\u0026rsquo;s being used to detail the costs of the different capabilities. Most of CLRS assumes the one-processor random-access machine (RAM) model. Instructions are executed sequentially.\nAnalysis is focused on worst-case running time, for three reasons:\n Gives an upper bound Happens fairly often (for some algorithms) Close to the \u0026ldquo;average case\u0026rdquo; for many algorithms  Later chapters will explore average-case running time via probabilistic analysis. There are also randomized algorithms that have an expected running time.\nOrder of Growth The analysis can be further simplified by reducing it to the rate of growth/order of growth. Therefore ignore:\n All lower order terms (Only the leading term is significant as $n \\rightarrow \\infty$) Constant coefficients (Less significant as $n \\rightarrow \\infty$)  This means that worst-case running time is only really relevant for very large $n$.\n","permalink":"https://andrelimzs.github.io/posts/getting-started/","summary":"Objective The main objective of CLRS is to introduce frameworks to design and analyze algorithms.\nTerminology Loop Invariant Something used to prove the correctness of an algorithm, with three properties:\n Initialization It is true prior to the first iteration of the loop Maintenance If it is true before an iteration, it remains true after that iteration Termination It helps show that the algorithm is correct after the loop terminates Commonly used in combination with the termination condition  Input Size, $n$ Depends on the problem, but commonly:","title":"CLRS - Getting Started"}]