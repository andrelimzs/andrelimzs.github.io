<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script>
<meta name=robots content="index, follow">
<title>CLRS - Getting Started | AndreLimZS</title>
<meta name=keywords content>
<meta name=description content="Objective The main objective of CLRS is to introduce frameworks to design and analyze algorithms.
Terminology Loop Invariant Something used to prove the correctness of an algorithm, with three properties:
 Initialization It is true prior to the first iteration of the loop Maintenance If it is true before an iteration, it remains true after that iteration Termination It helps show that the algorithm is correct after the loop terminates Commonly used in combination with the termination condition  Input Size, $n$ Depends on the problem, but commonly:">
<meta name=author content>
<link rel=canonical href=https://andrelimzs.github.io/posts/getting-started/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andrelimzs.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://andrelimzs.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://andrelimzs.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://andrelimzs.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://andrelimzs.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="CLRS - Getting Started">
<meta property="og:description" content="Objective The main objective of CLRS is to introduce frameworks to design and analyze algorithms.
Terminology Loop Invariant Something used to prove the correctness of an algorithm, with three properties:
 Initialization It is true prior to the first iteration of the loop Maintenance If it is true before an iteration, it remains true after that iteration Termination It helps show that the algorithm is correct after the loop terminates Commonly used in combination with the termination condition  Input Size, $n$ Depends on the problem, but commonly:">
<meta property="og:type" content="article">
<meta property="og:url" content="https://andrelimzs.github.io/posts/getting-started/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-16T17:43:50+08:00">
<meta property="article:modified_time" content="2022-01-16T17:43:50+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="CLRS - Getting Started">
<meta name=twitter:description content="Objective The main objective of CLRS is to introduce frameworks to design and analyze algorithms.
Terminology Loop Invariant Something used to prove the correctness of an algorithm, with three properties:
 Initialization It is true prior to the first iteration of the loop Maintenance If it is true before an iteration, it remains true after that iteration Termination It helps show that the algorithm is correct after the loop terminates Commonly used in combination with the termination condition  Input Size, $n$ Depends on the problem, but commonly:">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andrelimzs.github.io/posts/"},{"@type":"ListItem","position":3,"name":"CLRS - Getting Started","item":"https://andrelimzs.github.io/posts/getting-started/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CLRS - Getting Started","name":"CLRS - Getting Started","description":"Objective The main objective of CLRS is to introduce frameworks to design and analyze algorithms.\nTerminology Loop Invariant Something used to prove the correctness of an algorithm, with three properties:\n Initialization It is true prior to the first iteration of the loop Maintenance If it is true before an iteration, it remains true after that iteration Termination It helps show that the algorithm is correct after the loop terminates Commonly used in combination with the termination condition  Input Size, $n$ Depends on the problem, but commonly:","keywords":[],"articleBody":"Objective The main objective of CLRS is to introduce frameworks to design and analyze algorithms.\nTerminology Loop Invariant Something used to prove the correctness of an algorithm, with three properties:\n Initialization It is true prior to the first iteration of the loop Maintenance If it is true before an iteration, it remains true after that iteration Termination It helps show that the algorithm is correct after the loop terminates Commonly used in combination with the termination condition  Input Size, $n$ Depends on the problem, but commonly:\n Number of items in the input (sorting, FFT) Number of bits (multiplication)  It can also be described by more than one number, for example:\n Graph vertices and edges.  Runtime, $T(n)$  Number of primitive operations, or ‘steps’ executed\n Assume each line requires a constant amount of time. The running time of an algorithm is now: $$ \\sum \\text{each individual line} \\times \\text{num of times executed} $$\nRandom-access Machine (RAM) Model Instructions The RAM model contains commonly found instructions:\n Arithmetic (add, subtract, multiple, divide, remainder, floor, ceiling) Data Movement Load, store copy Control (Conditional, unconditional branch, subroutine call, return)  Data Types  Integers Floating point  And assume a limit on size of each word of data.\n For inputs of size $n$, assume integers are represented by $c \\log n$ bits for some constant $c \\geq 1$.\n $c \\geq 1$ : So that each word can hold the value of $n$ to allow us to index the last element $c$ constant : So that word size cannot grow arbitrarily large   Grey Area - Instructions There are some instructions included in real computers that are not in the list above. For example, exponentiation. CLRS assumes that they are constant-time operations for small exponent values.\nMemory Hierarchy The RAM model does not model memory hierarchy, such as caches or virtual memory. This is usually sufficient, and RAM models are excellent at predicting performance of real machines.\nAnalyzing Algorithms  “Predict the resources an algorithm requires”\n This resource is most often computation time.\nThis kind of analysis requires a model of the hardware that’s being used to detail the costs of the different capabilities. Most of CLRS assumes the one-processor random-access machine (RAM) model. Instructions are executed sequentially.\nAnalysis is focused on worst-case running time, for three reasons:\n Gives an upper bound Happens fairly often (for some algorithms) Close to the “average case” for many algorithms  Later chapters will explore average-case running time via probabilistic analysis. There are also randomized algorithms that have an expected running time.\nOrder of Growth The analysis can be further simplified by reducing it to the rate of growth/order of growth. Therefore ignore:\n All lower order terms (Only the leading term is significant as $n \\rightarrow \\infty$) Constant coefficients (Less significant as $n \\rightarrow \\infty$)  This means that worst-case running time is only really relevant for very large $n$.\n","wordCount":"472","inLanguage":"en","datePublished":"2022-01-16T17:43:50+08:00","dateModified":"2022-01-16T17:43:50+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://andrelimzs.github.io/posts/getting-started/"},"publisher":{"@type":"Organization","name":"AndreLimZS","logo":{"@type":"ImageObject","url":"https://andrelimzs.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://andrelimzs.github.io accesskey=h title="AndreLimZS (Alt + H)">AndreLimZS</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
CLRS - Getting Started
</h1>
<div class=post-meta><span title="2022-01-16 17:43:50 +0800 +0800">January 16, 2022</span>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#objective aria-label=Objective>Objective</a></li>
<li>
<a href=#terminology aria-label=Terminology>Terminology</a><ul>
<li>
<a href=#loop-invariant aria-label="Loop Invariant">Loop Invariant</a></li>
<li>
<a href=#input-size-n aria-label="Input Size, $n$">Input Size, $n$</a></li>
<li>
<a href=#runtime-tn aria-label="Runtime, $T(n)$">Runtime, $T(n)$</a></li>
<li>
<a href=#random-access-machine-ram-model aria-label="Random-access Machine (RAM) Model">Random-access Machine (RAM) Model</a><ul>
<li>
<a href=#instructions aria-label=Instructions>Instructions</a></li>
<li>
<a href=#data-types aria-label="Data Types">Data Types</a></li>
<li>
<a href=#grey-area---instructions aria-label="Grey Area - Instructions">Grey Area - Instructions</a></li>
<li>
<a href=#memory-hierarchy aria-label="Memory Hierarchy">Memory Hierarchy</a></li></ul>
</li></ul>
</li>
<li>
<a href=#analyzing-algorithms aria-label="Analyzing Algorithms">Analyzing Algorithms</a><ul>
<li>
<a href=#order-of-growth aria-label="Order of Growth">Order of Growth</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h2 id=objective>Objective<a hidden class=anchor aria-hidden=true href=#objective>#</a></h2>
<p>The main objective of CLRS is to introduce frameworks to design and analyze algorithms.</p>
<h2 id=terminology>Terminology<a hidden class=anchor aria-hidden=true href=#terminology>#</a></h2>
<h3 id=loop-invariant>Loop Invariant<a hidden class=anchor aria-hidden=true href=#loop-invariant>#</a></h3>
<p>Something used to prove the correctness of an algorithm, with three properties:</p>
<ol>
<li><strong>Initialization</strong> <br>
It is true prior to the first iteration of the loop</li>
<li><strong>Maintenance</strong> <br>
If it is true before an iteration, it remains true after that iteration</li>
<li><strong>Termination</strong> <br>
It helps show that the algorithm is correct after the loop terminates <br>
Commonly used in combination with the termination condition</li>
</ol>
<h3 id=input-size-n>Input Size, $n$<a hidden class=anchor aria-hidden=true href=#input-size-n>#</a></h3>
<p>Depends on the problem, but commonly:</p>
<ul>
<li><em>Number of items in the input</em> (sorting, FFT)</li>
<li><em>Number of bits</em> (multiplication)</li>
</ul>
<p>It can also be described by more than one number, for example:</p>
<ul>
<li>Graph vertices and edges.</li>
</ul>
<h3 id=runtime-tn>Runtime, $T(n)$<a hidden class=anchor aria-hidden=true href=#runtime-tn>#</a></h3>
<blockquote>
<p>Number of primitive operations, or &lsquo;steps&rsquo; executed</p>
</blockquote>
<p>Assume each line requires a constant amount of time. The running time of an algorithm is now:
$$
\sum \text{each individual line} \times \text{num of times executed}
$$</p>
<h3 id=random-access-machine-ram-model>Random-access Machine (RAM) Model<a hidden class=anchor aria-hidden=true href=#random-access-machine-ram-model>#</a></h3>
<h4 id=instructions>Instructions<a hidden class=anchor aria-hidden=true href=#instructions>#</a></h4>
<p>The RAM model contains commonly found instructions:</p>
<ul>
<li><strong>Arithmetic</strong> <br>
(add, subtract, multiple, divide, remainder, floor, ceiling)</li>
<li><strong>Data Movement</strong> <br>
Load, store copy</li>
<li><strong>Control</strong> <br>
(Conditional, unconditional branch, subroutine call, return)</li>
</ul>
<h4 id=data-types>Data Types<a hidden class=anchor aria-hidden=true href=#data-types>#</a></h4>
<ul>
<li><strong>Integers</strong></li>
<li><strong>Floating point</strong></li>
</ul>
<p>And assume a limit on size of each word of data.</p>
<blockquote>
<p>For inputs of size $n$, assume integers are represented by $c \log n$ bits for some constant $c \geq 1$.</p>
<ul>
<li>$c \geq 1$ : So that each word can hold the value of $n$ to allow us to index the last element</li>
<li>$c$ constant : So that word size cannot grow arbitrarily large</li>
</ul>
</blockquote>
<h4 id=grey-area---instructions>Grey Area - Instructions<a hidden class=anchor aria-hidden=true href=#grey-area---instructions>#</a></h4>
<p>There are some instructions included in real computers that are not in the list above. For example, exponentiation. CLRS assumes that they are constant-time operations for small exponent values.</p>
<h4 id=memory-hierarchy>Memory Hierarchy<a hidden class=anchor aria-hidden=true href=#memory-hierarchy>#</a></h4>
<p>The RAM model does <strong>not</strong> model memory hierarchy, such as caches or virtual memory. This is usually sufficient, and RAM models are excellent at predicting performance of real machines.</p>
<h2 id=analyzing-algorithms>Analyzing Algorithms<a hidden class=anchor aria-hidden=true href=#analyzing-algorithms>#</a></h2>
<blockquote>
<p>&ldquo;Predict the resources an algorithm requires&rdquo;</p>
</blockquote>
<p>This resource is most often <em>computation time</em>.</p>
<p>This kind of analysis requires a model of the hardware that&rsquo;s being used to detail the costs of the different capabilities. Most of CLRS assumes the one-processor <strong>random-access machine</strong> (<strong>RAM</strong>) model. Instructions are executed sequentially.</p>
<p>Analysis is focused on <strong>worst-case running time</strong>, for three reasons:</p>
<ul>
<li>Gives an upper bound</li>
<li>Happens fairly often (for some algorithms)</li>
<li>Close to the &ldquo;<em>average case</em>&rdquo; for many algorithms</li>
</ul>
<p>Later chapters will explore <strong>average-case running time</strong> via <em>probabilistic analysis</em>. There are also <em>randomized algorithms</em> that have an <em>expected running time</em>.</p>
<h3 id=order-of-growth>Order of Growth<a hidden class=anchor aria-hidden=true href=#order-of-growth>#</a></h3>
<p>The analysis can be further simplified by reducing it to the <strong>rate of growth</strong>/<strong>order of growth</strong>. Therefore ignore:</p>
<ul>
<li>All lower order terms
(Only the leading term is significant as $n \rightarrow \infty$)</li>
<li>Constant coefficients
(Less significant as $n \rightarrow \infty$)</li>
</ul>
<p>This means that worst-case running time is only really relevant for very large $n$.</p>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://andrelimzs.github.io>AndreLimZS</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>